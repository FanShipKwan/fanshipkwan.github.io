<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>No title | 因缺斯汀 | 一个怪石的呓语</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="">
  <meta name="description" content="PANDAS常用手册 I –读写文本数据标签： PYTHON科学计算


转载自实验楼作者 木木同学 的课程[《PYTHON数据分析》][1]

一、实验简介　　本实验将学习逐块读取文本文件、将数据写出到文本格式以及手工处理分隔符格式等知识。
　　输入输出通常可以划分为几个大类：读取文本文件和其他更高效的磁盘存储格式，加载数据库中的数据，利用 Web API 操作网络资源">
<meta property="og:type" content="article">
<meta property="og:title" content="No title">
<meta property="og:url" content="http://yoursite.com/2016/05/18/PANDAS常用手册-I-读写文本数据/index.html">
<meta property="og:site_name" content="因缺斯汀">
<meta property="og:description" content="PANDAS常用手册 I –读写文本数据标签： PYTHON科学计算


转载自实验楼作者 木木同学 的课程[《PYTHON数据分析》][1]

一、实验简介　　本实验将学习逐块读取文本文件、将数据写出到文本格式以及手工处理分隔符格式等知识。
　　输入输出通常可以划分为几个大类：读取文本文件和其他更高效的磁盘存储格式，加载数据库中的数据，利用 Web API 操作网络资源">
<meta property="og:updated_time" content="2016-05-18T15:40:05.773Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="No title">
<meta name="twitter:description" content="PANDAS常用手册 I –读写文本数据标签： PYTHON科学计算


转载自实验楼作者 木木同学 的课程[《PYTHON数据分析》][1]

一、实验简介　　本实验将学习逐块读取文本文件、将数据写出到文本格式以及手工处理分隔符格式等知识。
　　输入输出通常可以划分为几个大类：读取文本文件和其他更高效的磁盘存储格式，加载数据库中的数据，利用 Web API 操作网络资源">
  
    <link rel="alternative" href="/atom.xml" title="因缺斯汀" type="application/atom+xml">
  
  <meta name="summary" content="&lt;h1 id=&quot;PANDAS常用手册-I-–读写文本数据&quot;&gt;&lt;a href=&quot;#PANDAS常用手册-I-–读写文本数据&quot; class=&quot;headerlink&quot; title=&quot;PANDAS常用手册 I –读写文本数据&quot;&gt;&lt;/a&gt;PANDAS常用手册 I –读写文本数据&lt;/h1&gt;&lt;p&gt;标签： PYTHON科学计算&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;转载自实验楼作者 &lt;strong&gt;木木同学&lt;/strong&gt; 的课程[《PYTHON数据分析》][1]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、实验简介&quot;&gt;&lt;a href=&quot;#一、实验简介&quot; class=&quot;headerlink&quot; title=&quot;一、实验简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、实验简介&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;　　本实验将学习逐块读取文本文件、将数据写出到文本格式以及手工处理分隔符格式等知识。&lt;/p&gt;
&lt;p&gt;　　输入输出通常可以划分为几个大类：读取文本文件和其他更高效的磁盘存储格式，加载数据库中的数据，利用 Web API 操作网络资源&lt;br&gt;">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="loading" class="active"></div>

  <nav id="menu" class="hide" >
   <div class="inner">
  <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
      <i class="icon icon-lg icon-close"></i>
  </a>
  <div class="brand-wrap">
    <div class="brand">
      <a href="/" class="avatar"><img src="/img/logo.jpg"></a>
      <hgroup class="introduce">
        <h5 class="nickname">FanShipKwan</h5>
        <a href="mailto:undefined" title="634206017@qq.com" class="mail">634206017@qq.com</a>
      </hgroup>
    </div>
  </div>
  <ul class="nav">
    
        <li class="waves-block waves-effect">
          <a href="/"  >
            <i class="icon icon-lg icon-home"></i>
            主页
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/archives"  >
            <i class="icon icon-lg icon-archives"></i>
            Archives
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/tags"  >
            <i class="icon icon-lg icon-tags"></i>
            Tags
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="https://github.com/yscoder" target="_blank" >
            <i class="icon icon-lg icon-github"></i>
            Github
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="http://www.weibo.com/ysweb" target="_blank" >
            <i class="icon icon-lg icon-weibo"></i>
            Weibo
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/"  >
            <i class="icon icon-lg icon-link"></i>
            测试
          </a>
        </li>
    
  </ul>

  <footer class="footer">
  <p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC" /></a></p>
  <p>因缺斯汀 &copy; 2016</p>
  <p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
  <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p>
  <a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a>
</footer>

</div>

  </nav>
  <main id="main">
    <header class="header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">No title</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input " autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-share">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header">
  <div class="container">
    <h1 class="author">No title</h1>
    <h5 class="subtitle">2016-05-18</h5>
  </div>
</header>

    <div class="container body-wrap">
      
  <article id="post-PANDAS常用手册-I-读写文本数据" class="article article-type-post" itemprop="blogPost">
    
      <div class="post-meat flex-row">
        <div class="flex-col"></div>
      </div>
      <div class="post-body">

        <aside class="post-widget" id="post-widget">

          
          <div class="post-share" id="post-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>

          

          
          <nav class="post-toc-wrap" id="post-toc">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#PANDAS常用手册-I-–读写文本数据"><span class="post-toc-text">PANDAS常用手册 I –读写文本数据</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#一、实验简介"><span class="post-toc-text">一、实验简介</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二、逐块读取文本文件"><span class="post-toc-text">二、逐块读取文本文件</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#三、手工处理分隔符格式"><span class="post-toc-text">三、手工处理分隔符格式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#四、JSON-数据"><span class="post-toc-text">四、JSON 数据</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#五、XML-和-HTML"><span class="post-toc-text">五、XML 和 HTML</span></a></li></ol></li></ol>
          </nav>
          
        </aside>

        <div class="post-main">

            <div class="post-content" id="post-content" itemprop="postContent"><h1 id="PANDAS常用手册-I-–读写文本数据"><a href="#PANDAS常用手册-I-–读写文本数据" class="headerlink" title="PANDAS常用手册 I –读写文本数据"></a>PANDAS常用手册 I –读写文本数据</h1><p>标签： PYTHON科学计算</p>
<hr>
<blockquote>
<p>转载自实验楼作者 <strong>木木同学</strong> 的课程[《PYTHON数据分析》][1]</p>
</blockquote>
<h2 id="一、实验简介"><a href="#一、实验简介" class="headerlink" title="一、实验简介"></a><strong>一、实验简介</strong></h2><p>　　本实验将学习逐块读取文本文件、将数据写出到文本格式以及手工处理分隔符格式等知识。</p>
<p>　　输入输出通常可以划分为几个大类：读取文本文件和其他更高效的磁盘存储格式，加载数据库中的数据，利用 Web API 操作网络资源<br><a id="more"></a></p>
<h2 id="二、逐块读取文本文件"><a href="#二、逐块读取文本文件" class="headerlink" title="二、逐块读取文本文件"></a><strong>二、逐块读取文本文件</strong></h2><p>由于本节实验需要使用到python的lxml库，所以先在环境中安装：</p>
<p><code>pip install python-lxml</code></p>
<p>　　Python 在文本和文件的处理以其简单的文本交互语法、直观的数据结构，以及诸如元组打包解包之类的便利功能，深受人们喜爱。</p>
<p>　　pandas 提供了一些用于将表格型数据读取为 DataFrame 对象的函数。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>read_csv</code></td>
<td style="text-align:left">从文件、URL、文件型对象中加载带分隔符的数据。默认分隔符为逗号</td>
</tr>
<tr>
<td><code>read_table</code></td>
<td style="text-align:left">从文件、URL、文件型对象中加载带分隔符的数据。默认分隔符为制表符\t</td>
</tr>
<tr>
<td><code>read_fwf</code></td>
<td style="text-align:left">读取定宽列格式数据（也就是说，没有分隔符）</td>
</tr>
<tr>
<td><code>read_clipboard</code></td>
<td style="text-align:left">读取剪贴板中的数据，可以看做 read_table                         的剪贴板版。在将网页转换为表格时很有用</td>
</tr>
</tbody>
</table>
<p>　　<br>这些函数的选项可以划分为以下几大类：</p>
<blockquote>
<ul>
<li><strong>索引</strong>：将一个或多个列当做返回的 DataFrame 处理，以及是否从文件、用户获取列名</li>
<li><strong>类型推断和数据转换</strong>：包括用户定义值的转换、缺失值标记列表等</li>
<li><strong>日期解析</strong>：包括组合功，比如将分散在多个列中的日期时间信息组合成结果中的单个列</li>
<li><strong>迭代</strong>：支持对大文件进行逐块迭代</li>
<li><strong>不规整数据问题</strong>：跳过一些行、页脚、注释或其他一些不重要的东西（比如由成千上万个逗号隔开的数值数据）</li>
</ul>
</blockquote>
<p>类型推断（typeinference）是这些函数中最重要的功能之一，我们不需要指定列的类型到底是数值、整数、布尔值，还是字符串。日期和其他自定义类型的处理需要多花点功夫才行。</p>
<p>　　首先我们来看一个以逗号分隔（我这里用的是 CSV 文件，同学们用 txt 文件是一样的）的文本文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">11</span>]: !cat test.csv</span><br><span class="line">a,b,c,d,message</span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,hello</span><br><span class="line"><span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,world</span><br><span class="line"><span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,info</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: data = pd.read_csv(<span class="string">'test.csv'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: data</span><br><span class="line">Out[<span class="number">13</span>]:</span><br><span class="line">   a   b   c   d  message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>    hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>    world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>   <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>    info</span><br></pre></td></tr></table></figure></p>
<p>　　我们也可以用read_table，只不过需要指定分隔符而已：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">17</span>]: data = pd.read_table(<span class="string">'.test.csv'</span>,sep=<span class="string">','</span>)</span><br><span class="line">Out[<span class="number">17</span>]:</span><br><span class="line">   a   b   c   d  message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>    hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>    world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>   <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>    info</span><br></pre></td></tr></table></figure></p>
<p>　　在上面的例子中，我们在文本文件中写了标题行（即 message 那一行），但是不是所有文件都会有标题行，读入这种文件有两个办法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">19</span>]: !cat test.csv</span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,hello</span><br><span class="line"><span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,world</span><br><span class="line"><span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,info</span><br><span class="line">In [<span class="number">20</span>]: <span class="comment"># 我们可以让 PANDAS 为其分配默认的列明，也可以自己定义列明</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: pd.read_csv(<span class="string">'test.csv'</span>,header=<span class="keyword">None</span>)</span><br><span class="line">Out[<span class="number">21</span>]:</span><br><span class="line">   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>        <span class="number">4</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>    hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>    world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>   <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>    info</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]:pd.read_csv(<span class="string">'test.csv'</span>,names=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'d'</span>,<span class="string">'message'</span>])</span><br><span class="line">Out[<span class="number">22</span>]: </span><br><span class="line">   a   b   c   d  message</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>    hello</span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>    world</span><br><span class="line"><span class="number">2</span>  <span class="number">9</span>   <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>    info</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: <span class="comment">#假设我们希望 message 列作为 DataFrame 的索引</span></span><br><span class="line">In [<span class="number">24</span>]: <span class="comment">#我们可以通过 index_col 参数来指定</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: name = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'message'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: pd.read_csv(<span class="string">'test.csv'</span>,names = name, index_col = <span class="string">'message'</span>)</span><br><span class="line">Out[<span class="number">26</span>]: </span><br><span class="line">message   a   b   c   d  </span><br><span class="line">hello     <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>    </span><br><span class="line">world     <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>    </span><br><span class="line">info      <span class="number">9</span>   <span class="number">10</span>  <span class="number">11</span>  <span class="number">12</span>   </span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: !cat test2.csv</span><br><span class="line">key1,key2,value1,value2</span><br><span class="line">one,a,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">one,b,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">one,c,<span class="number">5</span>,<span class="number">6</span></span><br><span class="line">one,d,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">two,a,<span class="number">9</span>,<span class="number">10</span></span><br><span class="line">two,b,<span class="number">11</span>,<span class="number">12</span></span><br><span class="line">In [<span class="number">28</span>]: parsed = pd.read_csv(<span class="string">'test2.csv'</span>,index_col =[<span class="string">'key1'</span>,<span class="string">'key2'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]:parsed</span><br><span class="line">Out[<span class="number">28</span>]:</span><br><span class="line">                value1    value2</span><br><span class="line">key1    key2                  </span><br><span class="line">one        a         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line">           b         <span class="number">3</span>         <span class="number">4</span></span><br><span class="line">           c         <span class="number">5</span>         <span class="number">6</span></span><br><span class="line">           d         <span class="number">7</span>         <span class="number">8</span></span><br><span class="line">two        a         <span class="number">9</span>        <span class="number">10</span></span><br><span class="line">           b        <span class="number">11</span>        <span class="number">12</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]:pd.read_csv(<span class="string">'test2.csv'</span>)</span><br><span class="line">Out[<span class="number">30</span>]:</span><br><span class="line">   key1    key2    value1    value2</span><br><span class="line"><span class="number">0</span>  one        a         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">1</span>  one        b         <span class="number">3</span>         <span class="number">4</span></span><br><span class="line"><span class="number">2</span>  one        c         <span class="number">5</span>         <span class="number">6</span></span><br><span class="line"><span class="number">3</span>  one        d         <span class="number">7</span>         <span class="number">8</span></span><br><span class="line"><span class="number">4</span>  two        a         <span class="number">9</span>        <span class="number">10</span></span><br><span class="line"><span class="number">5</span>  two        b        <span class="number">11</span>        <span class="number">12</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: <span class="comment">#我们可以传入列编号或者列名实现一次层次化索引</span></span><br></pre></td></tr></table></figure></p>
<p>层次化索引</p>
<p>　　有些表格可能不是用固定的分隔符去分隔字段的（比如空白符或其他字符串）。对于这种情况，我们可以编写一个正则表达式来作为 read_table 的分隔符。</p>
<p>正则表达式</p>
<p>　　上面的文本中 <code>read_table</code>发现列名的数量比列的数量少1，于是推断第一列应该是 <code>DataFrame</code> 的索引。</p>
<p>　　<strong>我们现在就来看一看 <code>read_csv/read_table</code> 函数的参数:</strong><br>|参数|    说明|<br>| ————- |:————-|<br>|<code>path</code>    |表示文件系统位置、URL、文件型对象的字符串|<br>|<code>sep/delimiter</code>    |用于对行中各字段进行拆分的字符序列或正则表达式|<br>|<code>header</code>    |用作列名的行号。默认为0（第一行），如果没有 header 行就应该设置为 None|<br>|<code>index_col</code>    |用作行索引的列编号或列名。可以是单个名称/数字或由多个名称/数字组成的列表（层次化索引）|<br>|<code>names</code>|    用于结果的列名列表，结合 header= None|<br>|<code>skiprows</code>    |需要忽略的行数（从文件开始处算起），或需要跳过的行号列表（从0开始）|<br>|<code>na_values</code>    |一组用于替换 NA 的值|<br>|<code>comment</code>    |用于将注释信息从行尾拆分出去的字符（一个或多个）<br>|<code>parse_datas</code>    |尝试将数据解析为日期，默认为 False，如果为 True，则尝试解析所有列。此外，还可以指定需要解析的一组列号或列名。如果列表的元素为列表或元组，就会将多个列组合到一起再进行日期解析工作<br>|<code>keep_data_col</code>    |如果连接多列解析日期，则保持参与连接的列。默认为 False<br>|<code>converters</code>    |由列号/列名跟函数之间的映射关系组成的字典。例如，{‘foo’ : f}会对 foo 列的所有值应用函数 f<br>|<code>dayfirst</code>    |当解析有歧义的日期时，将其看做国际格式（例如，7/6/2012 → June 7,2012）。默认为 False<br>|<code>data_parser</code>    |用于解析日期的函数<br>|<code>nrows</code>    |需要读取的行数（从文件开始处算起）<br>|<code>iterator</code>    |返回一个 TextParser 以便逐块读取文件<br>|<code>chunksize</code>    |文件块的大小（用于迭代）<br>|<code>skip_footer</code>    |需要忽略的行数（从文件末尾处算起）<br>|<code>verbose</code>    |打印各种解析器输出信息，比如“非数值列中缺失值的数量”等|<br>|<code>encoding</code>    |用于 unicode 的文本编码格式|<br>|<code>squeeze</code>    |如果数据经解析后仅含一列，则返回 Series|<br>|<code>thousand</code>    |千分位分隔符，如,或者.|<br>　　在处理很大文件或找出大文件中的参数集以便后续处理时，我们可能只想读取文件的一小部分或逐块对文件进行迭代。</p>
<p>写入数据</p>
<p>规定 nrows</p>
<p>逐块读</p>
<h2 id="三、手工处理分隔符格式"><a href="#三、手工处理分隔符格式" class="headerlink" title="三、手工处理分隔符格式"></a><strong>三、手工处理分隔符格式</strong></h2><p>　　大部分存储在磁盘上的表格型数据都能用 <code>pandas.read_table</code>进行加载。然而，有时还是需要做一些手工处理。由于接收到含有畸形行的文件而使用 <code>read_table</code> 出毛病的情况并不少见。接下来我们来看一个例子：</p>
<p>手工处理</p>
<p>　　CSV文件的形式有很多。只需定义 <code>csv.Dialect</code> 的一个子类即可定义出新格式（如专门的分隔符、字符串引用约定、行结束符等）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">61</span>]: <span class="class"><span class="keyword">class</span> <span class="title">my_dialect</span><span class="params">(csv.Dialect)</span>:</span></span><br><span class="line">   ....:     lineterminator = <span class="string">'\n'</span></span><br><span class="line">   ....:     delimiter = <span class="string">';'</span></span><br><span class="line">   ....:     quotechar = <span class="string">'"'</span></span><br><span class="line">   ....:     </span><br><span class="line">In [<span class="number">62</span>]: reader = csv.reader(f, dialect=my_dialect, quoting = csv.QUOTE_ALL)</span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: reader</span><br><span class="line">Out[<span class="number">63</span>]: &lt;_csv.reader at <span class="number">0x1074c29f0</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: <span class="keyword">with</span> open(<span class="string">'mydata.csv'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">   ....:     writer = csv.writer(f,dialect = my_dialect,quoting = csv.QUOTE_ALL)</span><br><span class="line">   ....:     writer.writerow((<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>))</span><br><span class="line">   ....:     writer.writerow((<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>))</span><br><span class="line">   ....:     writer.writerow((<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>))</span><br><span class="line">   ....:     writer.writerow((<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>))</span><br><span class="line">   ....:</span><br></pre></td></tr></table></figure></p>
<h2 id="四、JSON-数据"><a href="#四、JSON-数据" class="headerlink" title="四、JSON 数据"></a><strong>四、JSON 数据</strong></h2><p>　　JSON（JavaScript Object Notation 的简称）已经成为通过 HTTP 请求在 Web 浏览器和其他应用程序之间发送数据的标准格式之一。它是一种比表格型文本格式（如 CSV）灵活得多的数据格式。如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">obj = <span class="string">"""</span><br><span class="line"> &#123; "name":"Limei",</span><br><span class="line">   "places_lived":["China","UK","Germany"],</span><br><span class="line">   "pet":null,</span><br><span class="line">   "siblings":[&#123;"name":"Liming","age":23,"pet":"Xiaobai"&#125;,</span><br><span class="line">               &#123;"name":"Lifang","age":33,"pet":"Xiaohei"&#125;]</span><br><span class="line"> &#125;</span><br><span class="line"> """</span></span><br></pre></td></tr></table></figure>
<p>　　除其空值 null 和一些其他的细微差别（如列表末尾不允许存在多余的逗号）之外，JSON 非常接近于有效的 Python 代码。基本类型有对象（字典）、数组（列表）、字符串、数值、布尔值以及 null。对象中所有的键都必须是字符串。许多 Python 库都可以读写 JSON 数据。我们将使用 json，因为它是构建与 Python 标准库中的。通过 <code>json.loads</code> 即可将 JSON 字符串转换成 Python 形式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">70</span>]: <span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: result = json.loads(obj)</span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: result</span><br><span class="line">Out[<span class="number">72</span>]: </span><br><span class="line">&#123;<span class="string">u'name'</span>: <span class="string">u'Limei'</span>,</span><br><span class="line"> <span class="string">u'pet'</span>: <span class="keyword">None</span>,</span><br><span class="line"> <span class="string">u'places_lived'</span>: [<span class="string">u'China'</span>, <span class="string">u'UK'</span>, <span class="string">u'Germany'</span>],</span><br><span class="line"> <span class="string">u'siblings'</span>: [&#123;<span class="string">u'age'</span>: <span class="number">23</span>, <span class="string">u'name'</span>: <span class="string">u'Liming'</span>, <span class="string">u'pet'</span>: <span class="string">u'Xiaobai'</span>&#125;,</span><br><span class="line">  &#123;<span class="string">u'age'</span>: <span class="number">33</span>, <span class="string">u'name'</span>: <span class="string">u'Lifang'</span>, <span class="string">u'pet'</span>: <span class="string">u'Xiaohei'</span>&#125;]&#125;</span><br></pre></td></tr></table></figure>
<p>　　相反，json.dumps则将 Python 对象转换成 JSON 格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">78</span>]: asjson = json.dumps(result)</span><br><span class="line"></span><br><span class="line">In [<span class="number">79</span>]: asjson</span><br><span class="line">Out[<span class="number">79</span>]: <span class="string">'&#123;"pet": null, "siblings": [&#123;"pet": "Xiaobai", "age": 23, "name": "Liming"&#125;, &#123;"pet": "Xiaohei", "age": 33, "name": "Lifang"&#125;], "name": "Limei", "places_lived": ["China", "UK", "Germany"]&#125;'</span></span><br></pre></td></tr></table></figure>
<p>　　如何将（一个或一组）JSON 对象转换为DataFrame 或其他便于分析的数据结构呢？最简单方便的方式是：向 DataFrame 构造器传入一组 JSON 对象，并选取数据字段的子集。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">80</span>]: siblings = DataFrame(result[<span class="string">'siblings'</span>],columns = [<span class="string">'name'</span>,<span class="string">'age'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: siblings</span><br><span class="line">Out[<span class="number">81</span>]: </span><br><span class="line">     name  age</span><br><span class="line"><span class="number">0</span>  Liming   <span class="number">23</span></span><br><span class="line"><span class="number">1</span>  Lifang   <span class="number">33</span></span><br></pre></td></tr></table></figure>
<h2 id="五、XML-和-HTML"><a href="#五、XML-和-HTML" class="headerlink" title="五、XML 和 HTML"></a><strong>五、XML 和 HTML</strong></h2><p>　　Python 有许多可以读写 HTML 和 XML 格式数据的库。lxml 就是其中之一，它能够高效且可靠地解析大文件。lxml 有多个编程接口。首先我要用 <code>lxml.html</code> 处理 HTML，然后再用 <code>lxml.objectify</code> 做一些 XML 处理。</p>
<p>　　许多网站都将数据放到 HTML 表格中以便在浏览器中查看，但不能以一种更易于机器阅读的格式（如 JSON、HTML 或 XML）进行下载</p>
<p>　　首先，找到我们希望获取数据的 URL，利用 urllib2 将其打开，然后用 lxml 解析得到的数据流，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">4</span>]: <span class="keyword">from</span> lxml.html <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: <span class="keyword">from</span> urllib2 <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: parsed = parse(urlopen(<span class="string">'http://finance.yahoo.com/q/hp?s=AAPL+Historical+Prices'</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: doc = parsed.getroot()</span><br></pre></td></tr></table></figure>
<p>　　通过这个对象，我们可以获取特定类型的所有 HTML 标签，比如含有所需数据的 <code>table</code> 标签。给这个简单的例子加点启发性，假设我们想得到该文档中所有的 URL 链接。HTML 中的链接是a标签。使用文档根节点的 <code>findall</code> 方法以及一个 XPath（对文档的“查询”的一种表示手段）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">links = doc.findall(<span class="string">'.//a'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: links[:<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">9</span>]: </span><br><span class="line">[&lt;Element a at <span class="number">0x10db065d0</span>&gt;,</span><br><span class="line"> &lt;Element a at <span class="number">0x10db06628</span>&gt;,</span><br><span class="line"> &lt;Element a at <span class="number">0x10db06680</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>　　但是这些是表示 HTML 元素的对象。要得到 URL 和链接文本，你必须使用各对象的 get 方法（针对 URL）和 text_content 方法（针对显示文本）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">11</span>]: lnk = links[<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: lnk</span><br><span class="line">Out[<span class="number">12</span>]: &lt;Element a at <span class="number">0x10db06788</span>&gt;`</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: lnk.get(<span class="string">'href'</span>)</span><br><span class="line">Out[<span class="number">13</span>]: <span class="string">'http://finance.yahoo.com/'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: lnk.text_content()</span><br><span class="line">Out[<span class="number">14</span>]: <span class="string">'Finance'</span></span><br></pre></td></tr></table></figure></p>
<p>　　因此编写下面这条列表推导式即可获取文档中的全部 URL：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">16</span>]: urls = [lnk.get(<span class="string">'href'</span>) <span class="keyword">for</span> lnk <span class="keyword">in</span> doc.findall(<span class="string">'.//a'</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: urls[:<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">17</span>]: </span><br><span class="line">[<span class="string">'https://www.yahoo.com/'</span>,</span><br><span class="line"> <span class="string">'https://mail.yahoo.com/?.intl=us&amp;.lang=en-US&amp;.src=ym'</span>,</span><br><span class="line"> <span class="string">'https://search.yahoo.com/search'</span>]</span><br></pre></td></tr></table></figure></p>
<p>　　现在，从文档中找出正确表格的办法就是反复试验了。有些网站会给目标表格加上一个<code>id</code>属性。试验了好久，终于在这个网站上找到了我们需要的表格：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">70</span>]: tables = doc.findall(<span class="string">'.//table'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: <span class="comment">#从70行试到了121行也是不容易的啊</span></span><br><span class="line">In [<span class="number">122</span>]: calls = tables[<span class="number">13</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: puts = tables[<span class="number">14</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: <span class="keyword">from</span> pandas.io.parsers <span class="keyword">import</span> TextParser</span><br><span class="line">In [<span class="number">125</span>]: <span class="comment">#由于数值型数据任然是字符串格式</span></span><br><span class="line">In [<span class="number">126</span>]: <span class="comment">#所以我们希望将部分列转换为浮点数格式</span></span><br><span class="line">In [<span class="number">127</span>]: <span class="comment">#pandas 恰好就有一个 TextParser 类</span></span><br><span class="line">In [<span class="number">128</span>]: <span class="comment">#用于自动类型转换</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">129</span>]: <span class="function"><span class="keyword">def</span> <span class="title">parse_options_data</span><span class="params">(table)</span>:</span></span><br><span class="line">   .....:     rows = table.findall(<span class="string">'.//tr'</span>)</span><br><span class="line">   .....:     <span class="comment">#每个表格都有一个标题行，然后才是数据行</span></span><br><span class="line">   .....:     header = _unpack(rows[<span class="number">0</span>],kind=<span class="string">'th'</span>)</span><br><span class="line">   .....:     <span class="comment">#对于标题行，就是 th 单元格</span></span><br><span class="line">   .....:     <span class="comment">#数据行，就是 td 单元格</span></span><br><span class="line">   .....:     data = [_unpack(r) <span class="keyword">for</span> r <span class="keyword">in</span> rows[<span class="number">1</span>:]]</span><br><span class="line">   .....:     <span class="keyword">return</span> TextParser(data,names=header).get_chunk()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [<span class="number">130</span>]: call_data = parse_options_data(calls)</span><br><span class="line">In [<span class="number">131</span>]: put_data = parse_options_data(puts)</span><br><span class="line"></span><br><span class="line">In [<span class="number">132</span>]: call_data[:<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">132</span>]: </span><br><span class="line">           Date    Open    High     Low   Close      Volume  \</span><br><span class="line"><span class="number">0</span>  Jul <span class="number">29</span>, <span class="number">2015</span>  <span class="number">123.15</span>  <span class="number">123.50</span>  <span class="number">122.27</span>  <span class="number">122.99</span>  <span class="number">35</span>,<span class="number">914</span>,<span class="number">200</span>   </span><br><span class="line"><span class="number">1</span>  Jul <span class="number">28</span>, <span class="number">2015</span>  <span class="number">123.38</span>  <span class="number">123.91</span>  <span class="number">122.55</span>  <span class="number">123.38</span>  <span class="number">33</span>,<span class="number">448</span>,<span class="number">900</span>   </span><br><span class="line"><span class="number">2</span>  Jul <span class="number">27</span>, <span class="number">2015</span>  <span class="number">123.09</span>  <span class="number">123.61</span>  <span class="number">122.12</span>  <span class="number">122.77</span>  <span class="number">44</span>,<span class="number">274</span>,<span class="number">800</span> </span><br><span class="line"></span><br><span class="line">   Adj Close*\n                              </span><br><span class="line"><span class="number">0</span>                                    <span class="number">122.99</span>  </span><br><span class="line"><span class="number">1</span>                                    <span class="number">123.38</span>  </span><br><span class="line"><span class="number">2</span>                                    <span class="number">122.77</span></span><br></pre></td></tr></table></figure></p>
<p>　　XML 是另一种常见的支持分层、嵌套数据以及元数据的结构化数据格式。现在我们来学习另一种用于操作 XML 数据的接口，即 <code>lxml.objectify</code></p>
<p>　　这里m 给同学们一个 xml 文件的内容，同学们用文本编译器生成一个 xml 文件即可：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">`&lt;INDICATOR&gt;  </span><br><span class="line">&lt;INDICATOR_SEQ&gt;373889&lt;/INDICATOR_SEQ&gt;  </span><br><span class="line">&lt;PARENT_SEQ&gt;&lt;/PARENT_SEQ&gt;  </span><br><span class="line">&lt;AGENCY_NAME&gt;Metro-North Railroad&lt;/AGENCY_NAME&gt;  </span><br><span class="line">&lt;INDICATOR_NAME&gt;Escalator Availability&lt;/INDICATOR_NAME&gt;  </span><br><span class="line">&lt;DESCRIPTION&gt;Percent of the time that escalators are operational`  </span><br><span class="line">`systemwide. The availability rate is based on physical observations performed  </span><br><span class="line">the morning of regular business days only. This is a new indicator the agency  </span><br><span class="line">began reporting in 2009.&lt;/DESCRIPTION&gt;  </span><br><span class="line">&lt;PERIOD_YEAR&gt;2011&lt;/PERIOD_YEAR&gt;  </span><br><span class="line">&lt;PERIOD_MONTH&gt;12&lt;/PERIOD_MONTH&gt;  </span><br><span class="line">&lt;CATEGORY&gt;Service Indicators&lt;/CATEGORY&gt;  </span><br><span class="line">&lt;FREQUENCY&gt;M&lt;/FREQUENCY&gt;  </span><br><span class="line">&lt;DESIRED_CHANGE&gt;U&lt;/DESIRED_CHANGE&gt;  </span><br><span class="line">&lt;INDICATOR_UNIT&gt;%&lt;/INDICATOR_UNIT&gt;  </span><br><span class="line">&lt;DECIMAL_PLACES&gt;1&lt;/DECIMAL_PLACES&gt;  </span><br><span class="line">&lt;YTD_TARGET&gt;97.00&lt;/YTD_TARGET&gt;  </span><br><span class="line">&lt;YTD_ACTUAL&gt;&lt;/YTD_ACTUAL&gt;  </span><br><span class="line">&lt;MONTHLY_TARGET&gt;97.00&lt;/MONTHLY_TARGET&gt;  </span><br><span class="line">&lt;MONTHLY_ACTUAL&gt;&lt;/MONTHLY_ACTUAL&gt;  </span><br><span class="line">&lt;/INDICATOR&gt;`</span><br></pre></td></tr></table></figure></p>
<p>　　好了，接下来我们就进入 <code>lxml.objectify</code> 的学习吧<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">In [3]: # 我们先用 lxml.objectify 解析该文件，然后通过getroot得到该XML文件的根节点的引用：</span><br><span class="line"></span><br><span class="line">In [4]: from lxml import objectify</span><br><span class="line"></span><br><span class="line">In [5]: path = 'Performance_MNR.xml'</span><br><span class="line"></span><br><span class="line">In [6]: parsed = objectify.parse(open(path))</span><br><span class="line"></span><br><span class="line">In [7]: root = parsed.getroot()</span><br><span class="line">In [3]: # 我们先用 lxml.objectify 解析该文件，然后通过getroot得到该XML文件的根节点的引用：</span><br><span class="line"></span><br><span class="line">In [4]: from lxml import objectify</span><br><span class="line"></span><br><span class="line">In [5]: path = 'Performance_MNR.xml'</span><br><span class="line"></span><br><span class="line">In [6]: parsed = objectify.parse(open(path))</span><br><span class="line"></span><br><span class="line">In [7]: root = parsed.getroot()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [8]: data = []</span><br><span class="line"></span><br><span class="line">In [9]: skip_fields = ['PARENT_SEQ''PARENT_SEQ', INDICATOR_SEQ', 'DESIRED_CHANGE', 'DECIMAL_PLACES']</span><br><span class="line"></span><br><span class="line">In [10]: for elt in root:</span><br><span class="line">   ....:     el_data = &#123;&#125;</span><br><span class="line">   ....:     for child in elt.getchildren():</span><br><span class="line">   ....:         if child.tag in skip_fields:</span><br><span class="line">   ....:             continue</span><br><span class="line">   ....:         el_data[child.tag] = child.pyval</span><br><span class="line">   ....:     data.append(el_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [11]: data</span><br><span class="line">Out[11]: </span><br><span class="line">[&#123;'AGENCY_NAME': 'Metro-North Railroad',</span><br><span class="line">  'CATEGORY': 'Service Indicators',</span><br><span class="line">  'DESCRIPTION': 'Percent of the time that escalators are operational  \nsystemwide. The availability rate is based on physical observations performed  \nthe morning of regular business days only. This is a new indicator the agency  \nbegan reporting in 2009.',</span><br><span class="line">  'FREQUENCY': 'M',</span><br><span class="line">  'INDICATOR_NAME': 'Escalator Availability',</span><br><span class="line">  'INDICATOR_UNIT': '%',</span><br><span class="line">  'MONTHLY_ACTUAL': u'',</span><br><span class="line">  'MONTHLY_TARGET': 97.0,</span><br><span class="line">  'PARENT_SEQ': u'',</span><br><span class="line">  'PERIOD_MONTH': 12,</span><br><span class="line">  'PERIOD_YEAR': 2011,</span><br><span class="line">  'YTD_ACTUAL': u'',</span><br><span class="line">  'YTD_TARGET': 97.0&#125;]</span><br></pre></td></tr></table></figure></p>
</div>

            
<nav class="post-nav flex-row">
  <div class="flex-col waves-block waves-effect prev">
    
      <a href="/2016/05/18/PANDAS常用手册-II-使用-HTML-和-Web-API/" title="(no title)" id="post-prev" class="post-nav-link">
        <i class="icon icon-chevron-left"></i>
        <span class="article-nav-title">上一篇</span>
      </a>
    
  </div>
  <div class="flex-col waves-block waves-effect next">
    
      <a href="/2016/05/16/2016-4-23-dotatalking/" title="(no title)" id="post-next" class="post-nav-link">
        <span class="article-nav-title">下一篇</span>
        <i class="icon icon-chevron-right"></i>
      </a>
    
  </div>

</nav>



            
<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="PANDAS常用手册-I-读写文本数据" data-title="" data-url="http://yoursite.com/2016/05/18/PANDAS常用手册-I-读写文本数据/index.html"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"ysblog"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>






        </div>

      </div>

    

  </article>



    </div>
  </main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>

<script>
var BLOG_SHARE = {
    title: "No title",
    pic: "/img/logo.jpg",
    summary: document.getElementsByName('summary')[0].content,
    url: "http://yoursite.com/2016/05/18/PANDAS常用手册-I-读写文本数据/index.html"
};
</script>
<div class="global-share" id="global-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>



<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script src="/js/main.js"></script>



<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<script type="text/template" id="search-tpl">
<li class="item">
    <a href="/{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</script>

<script src="/js/search.js"></script>









</body>
</html>
